<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="框架体系java的集合类很多，主要分为两大类：">
<meta property="og:type" content="article">
<meta property="og:title" content="集合框架">
<meta property="og:url" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="YPBlog">
<meta property="og:description" content="框架体系java的集合类很多，主要分为两大类：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4jANad.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211005085215965.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4XAQf0.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4XA1pV.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4j7r5j.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4xUxeS.png">
<meta property="og:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hUZJ1I.png">
<meta property="article:published_time" content="2021-04-26T13:30:37.000Z">
<meta property="article:modified_time" content="2021-10-06T11:11:28.795Z">
<meta property="article:author" content="youpeng">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4jANad.png">


<link rel="canonical" href="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>集合框架 | YPBlog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">YPBlog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">框架体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">Collection接口实现类的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E4%B8%8E-Vector"><span class="nav-number">3.</span> <span class="nav-text">ArrayList  与 Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#add-%E5%A2%9E%E5%8A%A0"><span class="nav-number">4.1.</span> <span class="nav-text">add    增加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#addAll-%E6%8A%8A%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8A%A0%E8%BF%9B%E6%9D%A5"><span class="nav-number">4.2.</span> <span class="nav-text">addAll    把另一个容器所有对象都加进来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contains-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="nav-number">4.3.</span> <span class="nav-text">contains    判断是否存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.</span> <span class="nav-text">get    获取指定位置的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-%E5%88%A0%E9%99%A4"><span class="nav-number">4.5.</span> <span class="nav-text">remove    删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2-set"><span class="nav-number">4.6.</span> <span class="nav-text">替换    set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#size-%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.7.</span> <span class="nav-text">size    大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toArray-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="nav-number">4.8.</span> <span class="nav-text">toArray    转换为数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clear-%E6%B8%85%E7%A9%BA"><span class="nav-number">4.9.</span> <span class="nav-text">clear    清空</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-list-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">遍历 list 的三种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="nav-number">6.</span> <span class="nav-text">用for循环遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="nav-number">7.</span> <span class="nav-text">迭代器遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E5%A2%9E%E5%BC%BA%E5%9E%8Bfor%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.</span> <span class="nav-text">用增强型for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">9.</span> <span class="nav-text">ArrayList 的底层操作机制源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">10.</span> <span class="nav-text">ArrayList底层源码解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E8%AF%B4%E6%98%8E"><span class="nav-number">11.</span> <span class="nav-text">Vector类的定义说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector-%E4%B8%8E-ArrayList%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">12.</span> <span class="nav-text">Vector 与 ArrayList的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList"><span class="nav-number">13.</span> <span class="nav-text">集合框架 LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">14.</span> <span class="nav-text">LinkedList 的底层操作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E6%AF%94%E8%BE%83"><span class="nav-number">14.1.</span> <span class="nav-text">ArrayList和LinkedList比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="nav-number">15.</span> <span class="nav-text">队列 - Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">16.</span> <span class="nav-text">Set接口和常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">16.1.</span> <span class="nav-text">Set接口常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-number">16.2.</span> <span class="nav-text">Set接口的遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E5%85%A8%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="nav-number">16.3.</span> <span class="nav-text">HashSet全面说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E"><span class="nav-number">16.4.</span> <span class="nav-text">HashSet 底层机制说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%BA%E5%88%B6"><span class="nav-number">16.5.</span> <span class="nav-text">HashSet的扩容和转成红黑树机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E2%80%94-LinkedHashSet"><span class="nav-number">16.6.</span> <span class="nav-text">Set接口实现类 — LinkedHashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet%E8%AF%B4%E6%98%8E"><span class="nav-number">16.7.</span> <span class="nav-text">TreeSet说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">17.</span> <span class="nav-text">Map接口和常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">17.1.</span> <span class="nav-text">Map接口的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">17.2.</span> <span class="nav-text">Map接口遍历方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E2%80%94-HashMap"><span class="nav-number">18.</span> <span class="nav-text">Map接口的实现类 — HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">18.1.</span> <span class="nav-text">HashMap 底层机制及源码剖析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%B0%8F%E7%BB%93"><span class="nav-number">18.2.</span> <span class="nav-text">HashMap小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E2%80%94-HashTable"><span class="nav-number">19.</span> <span class="nav-text">Map 接口实现类 — HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">19.1.</span> <span class="nav-text">HashTable基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable%E5%BA%95%E5%B1%82"><span class="nav-number">19.2.</span> <span class="nav-text">HashTable底层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable-%E5%92%8C-HashMap-%E5%AF%B9%E6%AF%94"><span class="nav-number">19.3.</span> <span class="nav-text">HashTable 和 HashMap 对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E2%80%94-HashTable%E5%AD%90%E7%B1%BB-Properties"><span class="nav-number">20.</span> <span class="nav-text">Map 接口实现类 — HashTable子类    Properties</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">20.1.</span> <span class="nav-text">基本介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E2%80%94-TreeMap"><span class="nav-number">21.</span> <span class="nav-text">Map 接口实现类 — TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="nav-number">21.1.</span> <span class="nav-text">使用队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8PriorityQueue"><span class="nav-number">21.2.</span> <span class="nav-text">使用PriorityQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Deque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">21.3.</span> <span class="nav-text">使用Deque 双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Stack"><span class="nav-number">21.4.</span> <span class="nav-text">使用Stack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%B7%A5%E5%85%B7%E7%B1%BBCollections"><span class="nav-number">22.</span> <span class="nav-text">Java工具类Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">22.1.</span> <span class="nav-text">Collections 工具类介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9D%87%E4%B8%BAstatic%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">22.2.</span> <span class="nav-text">排序操作（均为static方法）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">youpeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youpeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YPBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          集合框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-26 21:30:37" itemprop="dateCreated datePublished" datetime="2021-04-26T21:30:37+08:00">2021-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-10-06 19:11:28" itemprop="dateModified" datetime="2021-10-06T19:11:28+08:00">2021-10-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="框架体系"><a href="#框架体系" class="headerlink" title="框架体系"></a>框架体系</h3><p>java的集合类很多，主要分为两大类：</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4jANad"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4jANad.png" alt="4jANad.png"></a></p>
<p><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211005085215965.png" alt="image-20211005085215965"></p>
<ul>
<li>集合主要是两组（单列集合、双列集合）</li>
<li>Collection接口有两个重要的子接口 List Set，它们的实现子类都是单列集合</li>
<li>Map接口的实现子类，是双列结合，存放的 K-V键值对</li>
</ul>
<h3 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h3><ol>
<li>Collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）</li>
<li>Collection接口没有直接的实现子类，是通过他的子接口 List 和 Set 来实现的</li>
</ol>
<h3 id="ArrayList-与-Vector"><a href="#ArrayList-与-Vector" class="headerlink" title="ArrayList  与 Vector"></a>ArrayList  与 Vector</h3><p>ArrayList是线程不安全的，Vector是线程安全的</p>
<p>ArrayList实现了接口List,常见的写法会把引用声明为接口List类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="add-增加"><a href="#add-增加" class="headerlink" title="add    增加"></a>add    增加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> list.add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在指定位子添加    list下标从0开始，第二个位子上插入5 </span></span><br><span class="line">list.add(<span class="number">2</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="addAll-把另一个容器所有对象都加进来"><a href="#addAll-把另一个容器所有对象都加进来" class="headerlink" title="addAll    把另一个容器所有对象都加进来"></a>addAll    把另一个容器所有对象都加进来</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList anotherList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.addAll(anotherList);</span><br></pre></td></tr></table></figure>

<h4 id="contains-判断是否存在"><a href="#contains-判断是否存在" class="headerlink" title="contains    判断是否存在"></a>contains    判断是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(<span class="number">2</span>); <span class="comment">//返回true or false</span></span><br></pre></td></tr></table></figure>

<h4 id="get-获取指定位置的对象"><a href="#get-获取指定位置的对象" class="headerlink" title="get    获取指定位置的对象"></a>get    获取指定位置的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.get(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="remove-删除"><a href="#remove-删除" class="headerlink" title="remove    删除"></a>remove    删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove可以根据下标删除ArrayList的元素</span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//也可以根据对象删除</span></span><br><span class="line">list.remove(object);</span><br></pre></td></tr></table></figure>

<h4 id="替换-set"><a href="#替换-set" class="headerlink" title="替换    set"></a>替换    set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把下标是2的元素，替换为6</span></span><br><span class="line">list.set(<span class="number">2</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h4 id="size-大小"><a href="#size-大小" class="headerlink" title="size    大小"></a>size    大小</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.size();</span><br></pre></td></tr></table></figure>

<h4 id="toArray-转换为数组"><a href="#toArray-转换为数组" class="headerlink" title="toArray    转换为数组"></a>toArray    转换为数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.toArray();</span><br></pre></td></tr></table></figure>

<h4 id="clear-清空"><a href="#clear-清空" class="headerlink" title="clear    清空"></a>clear    清空</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.clear();</span><br></pre></td></tr></table></figure>



<h3 id="遍历-list-的三种方法"><a href="#遍历-list-的三种方法" class="headerlink" title="遍历 list 的三种方法"></a>遍历 list 的三种方法</h3><h3 id="用for循环遍历"><a href="#用for循环遍历" class="headerlink" title="用for循环遍历"></a>用for循环遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = list.get(i);</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>迭代器，从头空的位置开始判断，hasNext判断是否有下一个，如果有就取出来，然后指针往下移，直到移动到最后一个位子，hasNext返回false，表示后面没有了数据，迭代完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种遍历，使用迭代器</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------使用while的iterator-------&quot;</span>);</span><br><span class="line">Iterator it= list.iterator();</span><br><span class="line"><span class="comment">//从最开始的位置判断&quot;下一个&quot;位置是否有数据</span></span><br><span class="line"><span class="comment">//如果有就通过next取出来，并且把指针向下移动</span></span><br><span class="line"><span class="comment">//直到&quot;下一个&quot;位置没有数据</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> h = it.next();</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器的for写法</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------使用for的iterator-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>) iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用增强型for循环"><a href="#用增强型for循环" class="headerlink" title="用增强型for循环"></a>用增强型for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ArrayList-的底层操作机制源码分析"><a href="#ArrayList-的底层操作机制源码分析" class="headerlink" title="ArrayList 的底层操作机制源码分析"></a>ArrayList 的底层操作机制源码分析</h3><ol>
<li><p>ArrayList中维护了一个 Object类型的数组elementData</p>
<p>transient Object[] elementData; // transient 表示该属性不会被序列化 </p>
</li>
<li><p>当创建 ArrayList 对象时，如果使用的是无参构造，则初始 elementData容量为0，第一次添加，则扩容elementData为10，如果需要再次扩容，则扩容 elementData为1.5倍</p>
</li>
<li><p>如果直接使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用无参构造器创建ArrayList 对象</span></span><br><span class="line">    <span class="comment">//ArrayList list = new ArrayList();</span></span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//使用for 给list 集合添加 1-10 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用for 给list 集合添加 11-15 数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(<span class="number">100</span>);</span><br><span class="line">    list.add(<span class="number">200</span>);</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ArrayList底层源码解析"><a href="#ArrayList底层源码解析" class="headerlink" title="ArrayList底层源码解析"></a>ArrayList底层源码解析</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4XAQf0"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4XAQf0.png" alt="4XAQf0.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4XA1pV"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4XA1pV.png" alt="4XA1pV.png"></a></p>
<h3 id="Vector类的定义说明"><a href="#Vector类的定义说明" class="headerlink" title="Vector类的定义说明"></a>Vector类的定义说明</h3><ol>
<li>Vector底层也是一个对象数组，protected Object[] elementData；</li>
<li>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</li>
<li>在开发中，需要线程同步安全时，考虑使用Vector</li>
</ol>
<h3 id="Vector-与-ArrayList的比较"><a href="#Vector-与-ArrayList的比较" class="headerlink" title="Vector 与 ArrayList的比较"></a>Vector 与 ArrayList的比较</h3><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程安全、效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>jdk1.2</td>
<td>不安全效率高</td>
<td>有参构造1.5倍  无参 1. 第一次10 2.第二次按1.5</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组Object[]</td>
<td>jdk1.0</td>
<td>安全、效率不高</td>
<td>无参 默认10，满后 按两倍扩容。如果指定大小，每次按两倍扩</td>
</tr>
</tbody></table>
<h3 id="集合框架-LinkedList"><a href="#集合框架-LinkedList" class="headerlink" title="集合框架 LinkedList"></a>集合框架 LinkedList</h3><ul>
<li>LinkedList底层实现了双向链表和双端队列的特点</li>
<li>可以田间任意元素（元素可以重复，包括null）</li>
<li>线程不安全，没有实现同步</li>
</ul>
<h3 id="LinkedList-的底层操作机制"><a href="#LinkedList-的底层操作机制" class="headerlink" title="LinkedList 的底层操作机制"></a>LinkedList 的底层操作机制</h3><ol>
<li>LinkedList 底层维护了一个双向链表</li>
<li>LinkedList 中维护了两个属性 first 和 last 分别指向 首节点和尾节点</li>
<li>每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表。</li>
<li>所以 LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率要高</li>
</ol>
<p>双向链表 - Deque  </p>
<p>LinkedList 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//LinkedList是一个双向链表结构的list</span></span><br><span class="line">        LinkedList&lt;Hero&gt; ll =<span class="keyword">new</span> LinkedList&lt;Hero&gt;();     </span><br><span class="line">        <span class="comment">//所以可以很方便的在头部和尾部插入数据</span></span><br><span class="line">        <span class="comment">//在最后插入新的英雄</span></span><br><span class="line">        ll.addLast(<span class="keyword">new</span> Hero(<span class="string">&quot;hero1&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> Hero(<span class="string">&quot;hero2&quot;</span>));</span><br><span class="line">        ll.addLast(<span class="keyword">new</span> Hero(<span class="string">&quot;hero3&quot;</span>));</span><br><span class="line">        System.out.println(ll);     </span><br><span class="line">        <span class="comment">//在最前面插入新的英雄</span></span><br><span class="line">        ll.addFirst(<span class="keyword">new</span> Hero(<span class="string">&quot;heroX&quot;</span>));</span><br><span class="line">        System.out.println(ll);     </span><br><span class="line">        <span class="comment">//查看最前面的英雄</span></span><br><span class="line">        System.out.println(ll.getFirst());</span><br><span class="line">        <span class="comment">//查看最后面的英雄</span></span><br><span class="line">        System.out.println(ll.getLast());   </span><br><span class="line">        <span class="comment">//查看不会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);</span><br><span class="line">        <span class="comment">//取出最前面的英雄</span></span><br><span class="line">        System.out.println(ll.removeFirst());  </span><br><span class="line">        <span class="comment">//取出最后面的英雄</span></span><br><span class="line">        System.out.println(ll.removeLast());  </span><br><span class="line">        <span class="comment">//取出会导致英雄被删除</span></span><br><span class="line">        System.out.println(ll);    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h4><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删的效率</th>
<th>改查的效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低 数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高 通过链表追加</td>
<td>较低</td>
</tr>
</tbody></table>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 - Queue"></a>队列 - Queue</h3><p>Queue是先进先出队列 FIFO，常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offer 	在最后添加元素</span><br><span class="line">poll 	取出第一个元素</span><br><span class="line">peek 	查看第一个元素</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//和ArrayList一样，LinkedList也实现了List接口</span></span><br><span class="line">    List ll =<span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span></span><br><span class="line">    <span class="comment">//Queue代表FIFO 先进先出的队列</span></span><br><span class="line">    Queue&lt;Hero&gt; q= <span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加在队列的最后面</span></span><br><span class="line">    System.out.print(<span class="string">&quot;初始化队列：\t&quot;</span>);</span><br><span class="line">    q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero1&quot;</span>));</span><br><span class="line">    q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero2&quot;</span>));</span><br><span class="line">    q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero3&quot;</span>));</span><br><span class="line">    q.offer(<span class="keyword">new</span> Hero(<span class="string">&quot;Hero4&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(q);</span><br><span class="line">    System.out.print(<span class="string">&quot;把第一个元素取poll()出来:\t&quot;</span>);</span><br><span class="line">    <span class="comment">//取出第一个Hero，FIFO 先进先出</span></span><br><span class="line">    Hero h = q.poll();</span><br><span class="line">    System.out.println(h);</span><br><span class="line">    System.out.print(<span class="string">&quot;取出第一个元素之后的队列:\t&quot;</span>);</span><br><span class="line">    System.out.println(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把第一个拿出来看一看，但是不取出来</span></span><br><span class="line">    h=q.peek();</span><br><span class="line">    System.out.print(<span class="string">&quot;查看peek()第一个元素:\t&quot;</span>);</span><br><span class="line">    System.out.println(h);</span><br><span class="line">    System.out.print(<span class="string">&quot;查看并不会导致第一个元素被取出来:\t&quot;</span>);</span><br><span class="line">    System.out.println(q);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="Set接口和常用方法"><a href="#Set接口和常用方法" class="headerlink" title="Set接口和常用方法"></a>Set接口和常用方法</h3><ul>
<li>无序（添加和取出的顺序不一致）</li>
<li>不允许重复元素，所以最多包含一个null</li>
<li>JDK API中Set接口的实现类有：HashSet 、TreeSet</li>
</ul>
<h4 id="Set接口常用方法"><a href="#Set接口常用方法" class="headerlink" title="Set接口常用方法"></a>Set接口常用方法</h4><p>和List接口一样，Set接口也是Collection接口的子接口，因此常用方法和Collection接口一样</p>
<h4 id="Set接口的遍历方式"><a href="#Set接口的遍历方式" class="headerlink" title="Set接口的遍历方式"></a>Set接口的遍历方式</h4><p>同Collection的遍历方式一样，因为Set接口是Collection的子接口</p>
<ol>
<li>使用迭代器</li>
<li>增强for循环</li>
<li>不能使用索引的方式来获取</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;Integer&gt;();   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        numbers.add(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//Set不提供get方法来获取指定位置的元素  numbers.get(0)不存在       </span></span><br><span class="line">    <span class="comment">//遍历Set可以采用迭代器iterator</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = numbers.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//或者采用增强型for循环</span></span><br><span class="line">    <span class="keyword">for</span> (Integer i : numbers) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet全面说明"><a href="#HashSet全面说明" class="headerlink" title="HashSet全面说明"></a>HashSet全面说明</h4><ol>
<li><p>HashSet实现了Set接口</p>
</li>
<li><p>HashSet实际上是HashMap（根据源码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以存放null，但是只能有一个null</p>
</li>
<li><p>HashSet不保证元素有序，取决于Hash后，在确定索引结果（不保证存入与取出顺序一致）</p>
</li>
<li><p>不能有重复元素/对象</p>
</li>
</ol>
<h4 id="HashSet-底层机制说明"><a href="#HashSet-底层机制说明" class="headerlink" title="HashSet 底层机制说明"></a>HashSet 底层机制说明</h4><ol>
<li>HashSet底层是HashMap</li>
<li>添加一个元素时，会先得到hash值 -会转成-&gt;索引值</li>
<li>找到存储数据表table，看这个索引位置是否已经存放的有元素如果没有，直接加入</li>
<li>如果有，调用equals比较，如果相同，就放弃添加。如果不同则以链表的方式添加</li>
<li>在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIEF_CAPACITY（默认64），就会进行树化（红黑树）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);<span class="comment">//到此位置，第1 次add 分析完毕.</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);<span class="comment">//到此位置，第2 次add 分析完毕</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set=&quot;</span> + hashSet);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 执行 HashSet()</span></span><br><span class="line"><span class="comment">            public HashSet() &#123;</span></span><br><span class="line"><span class="comment">            map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        2. 执行 add()</span></span><br><span class="line"><span class="comment">            public boolean add(E e) &#123;//e = &quot;java&quot;</span></span><br><span class="line"><span class="comment">            return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        3.执行 put() , 该方法会执行 hash(key) 得到key 对应的hash 值 算法h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">            public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享</span></span><br><span class="line"><span class="comment">            return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">            4.执行 putVal</span></span><br><span class="line"><span class="comment">            final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                           boolean evict) &#123;</span></span><br><span class="line"><span class="comment">            Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量</span></span><br><span class="line"><span class="comment">            //table 就是 HashMap 的一个数组，类型是 Node[]</span></span><br><span class="line"><span class="comment">            //if 语句表示如果当前table 是null, 或者 大小=0</span></span><br><span class="line"><span class="comment">            //就是第一次扩容，到16 个空间.</span></span><br><span class="line"><span class="comment">            if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">                n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">            //(1)根据key，得到hash 去计算该key 应该存放到table 表的哪个索引位置 并把这个位置的对象，赋给 p</span></span><br><span class="line"><span class="comment">            //(2)判断p 是否为null</span></span><br><span class="line"><span class="comment">            //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key=&quot;java&quot;,value=PRESENT)</span></span><br><span class="line"><span class="comment">            //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)</span></span><br><span class="line"><span class="comment">            if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建</span></span><br><span class="line"><span class="comment">                Node&lt;K,V&gt; e; K k; //</span></span><br><span class="line"><span class="comment">                //如果当前索引位置对应的链表的第一个元素和准备添加的key 的hash 值一样</span></span><br><span class="line"><span class="comment">                //并且满足 下面两个条件之一:</span></span><br><span class="line"><span class="comment">                //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象</span></span><br><span class="line"><span class="comment">                //(2) p 指向的Node 结点的 key 的equals() 和准备加入的key 比较后相同就不能加入</span></span><br><span class="line"><span class="comment">                    if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        e = p;</span></span><br><span class="line"><span class="comment">                //再判断 p 是不是一颗红黑树,</span></span><br><span class="line"><span class="comment">                //如果是一颗红黑树，就调用 putTreeVal , 来进行添加</span></span><br><span class="line"><span class="comment">                else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">                else &#123;//如果table 对应索引位置，已经是一个链表, 就使用for 循环比较</span></span><br><span class="line"><span class="comment">                    //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后</span></span><br><span class="line"><span class="comment">                    // 注意在把元素添加到链表后，立即判断 该链表是否已经达到8 个结点</span></span><br><span class="line"><span class="comment">                    // , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)</span></span><br><span class="line"><span class="comment">                    // 注意，在转成红黑树时，要进行判断, 判断条件</span></span><br><span class="line"><span class="comment">                    // if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))</span></span><br><span class="line"><span class="comment">                    // resize();</span></span><br><span class="line"><span class="comment">                    // 如果上面条件成立，先table 扩容.</span></span><br><span class="line"><span class="comment">                    // 只有上面条件不成立时，才进行转成红黑树</span></span><br><span class="line"><span class="comment">                    //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break</span></span><br><span class="line"><span class="comment">                    for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                        if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                            p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                            if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                                treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                            break;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                        if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                            韩顺平循序渐进学Java 零基础</span></span><br><span class="line"><span class="comment">                            第651页</span></span><br><span class="line"><span class="comment">                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                            break;</span></span><br><span class="line"><span class="comment">                        p = e;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                    V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                    if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                        e.value = value;</span></span><br><span class="line"><span class="comment">                    afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                    return oldValue;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ++modCount;</span></span><br><span class="line"><span class="comment">            //size 就是我们每加入一个结点Node(k,v,h,next), size++</span></span><br><span class="line"><span class="comment">            if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">                resize();//扩容</span></span><br><span class="line"><span class="comment">            afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">            return null;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br></pre></td></tr></table></figure>



<h4 id="HashSet的扩容和转成红黑树机制"><a href="#HashSet的扩容和转成红黑树机制" class="headerlink" title="HashSet的扩容和转成红黑树机制"></a>HashSet的扩容和转成红黑树机制</h4><ol>
<li>HAshSet底层是HashMpa，第一次添加时，table数组扩容到16，临界（threshold）是16*加载因子（loadFactor）是0.75 = 12</li>
<li>如果table数组使用了临界值12，就会扩容到16 * 2 = 32，进的临界值就是 32 * 0.75 = 24，以此类推</li>
<li>在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIEF_CAPACITY（默认64），就会进行树化（红黑树），否则仍然采用数组机制扩容</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		HashSet 底层是HashMap, 第一次添加时，table 数组扩容到 16，临界值(threshold)是 16*加载因子(loadFactor)是0.75 = 12如果table 数组使用到了临界值 12,就会扩容到 16 * 2 = 32,新的临界值就是 32*0.75 = 24, 依次类推*/</span></span><br><span class="line">        HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= 100; i++) &#123;</span></span><br><span class="line">        <span class="comment">// hashSet.add(i);//1,2,3,4,5...100</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">在Java8 中, 如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是 8 )，</span></span><br><span class="line"><span class="comment">并且table 的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64),就会进行树化(红黑树),</span></span><br><span class="line"><span class="comment">否则仍然采用数组扩容机制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= 12; i++) &#123;</span></span><br><span class="line">        <span class="comment">// hashSet.add(new A(i));//</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">当我们向hashset 增加一个元素，-&gt; Node -&gt; 加入table , 就算是增加了一个size++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;<span class="comment">//在table 的某一条链表上添加了 7 个A 对象</span></span><br><span class="line">            hashSet.add(<span class="keyword">new</span> A(i));<span class="comment">//</span></span><br><span class="line">            韩顺平循序渐进学Java 零基础</span><br><span class="line">                第<span class="number">654</span>页</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;<span class="comment">//在table 的另外一条链表上添加了 7 个B 对象</span></span><br><span class="line">            hashSet.add(<span class="keyword">new</span> B(i));<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    韩顺平循序渐进学Java 零基础</span><br><span class="line">        第<span class="number">655</span>页</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set接口实现类-—-LinkedHashSet"><a href="#Set接口实现类-—-LinkedHashSet" class="headerlink" title="Set接口实现类 — LinkedHashSet"></a>Set接口实现类 — LinkedHashSet</h4><p>LinkedHashSet全面说明</p>
<ol>
<li>LinkedHashSet 是 HashSet 的子类</li>
<li>LinkedHashSet 底层是一个LinkedHashMap ，底层维护一个 数组 + 双链表</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li>
<li>LinkedHashSet 不允许添加重复元素</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4j7r5j"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4j7r5j.png" alt="4j7r5j.png"></a></p>
<p>​    </p>
<h4 id="TreeSet说明"><a href="#TreeSet说明" class="headerlink" title="TreeSet说明"></a>TreeSet说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 当我们使用无参构造器，创建TreeSet 时，仍然是无序的</span></span><br><span class="line">    <span class="comment">//2. 希望添加的元素，按照字符串大小来排序</span></span><br><span class="line">    <span class="comment">//3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)</span></span><br><span class="line">    <span class="comment">// 并指定排序规则</span></span><br><span class="line">    <span class="comment">//4. 简单看看源码</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性this.comparator</span></span><br><span class="line"><span class="comment">        public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span></span><br><span class="line"><span class="comment">        this.comparator = comparator;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到</span></span><br><span class="line"><span class="comment">        if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span></span><br><span class="line"><span class="comment">            韩顺平循序渐进学Java 零基础</span></span><br><span class="line"><span class="comment">                第688页</span></span><br><span class="line"><span class="comment">                do &#123;</span></span><br><span class="line"><span class="comment">                    parent = t;</span></span><br><span class="line"><span class="comment">                    //动态绑定到我们的匿名内部类(对象)compare</span></span><br><span class="line"><span class="comment">                    cmp = cpr.compare(key, t.key);</span></span><br><span class="line"><span class="comment">                    if (cmp &lt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.left;</span></span><br><span class="line"><span class="comment">                    else if (cmp &gt; 0)</span></span><br><span class="line"><span class="comment">                        t = t.right;</span></span><br><span class="line"><span class="comment">                    else //如果相等，即返回0,这个Key 就没有加入</span></span><br><span class="line"><span class="comment">                        return t.setValue(value);</span></span><br><span class="line"><span class="comment">                &#125; while (t != null);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// TreeSet treeSet = new TreeSet();</span></span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//下面 调用String 的 compareTo 方法进行字符串大小比较</span></span><br><span class="line">            <span class="comment">//按照长度大小排序</span></span><br><span class="line">            <span class="comment">//return ((String) o2).compareTo((String) o1);</span></span><br><span class="line">            <span class="keyword">return</span> ((String) o1).length() - ((String) o2).length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//添加数据.</span></span><br><span class="line">    treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    韩顺平循序渐进学Java 零基础</span><br><span class="line">        第<span class="number">689</span>页</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);<span class="comment">//3</span></span><br><span class="line">    treeSet.add(<span class="string">&quot;sp&quot;</span>);</span><br><span class="line">    treeSet.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    treeSet.add(<span class="string">&quot;abc&quot;</span>);<span class="comment">//3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;treeSet=&quot;</span> + treeSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Map接口和常用方法"><a href="#Map接口和常用方法" class="headerlink" title="Map接口和常用方法"></a>Map接口和常用方法</h3><ol>
<li>Map 与Collection并列存在。用于保存具有映射关系的数据：Key - Value</li>
<li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node对象中</li>
<li>Map 中的 key 不允许重复，原因是和 HashSet 一样 （分析过源码）</li>
<li>Map 中的 value 可以重复</li>
<li>Map 中的key 可以为 null，value 也可以为null</li>
<li>常用String类作为Map的key</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/4xUxeS"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/4xUxeS.png" alt="4xUxeS.png"></a></p>
<p>map中的 key 和 value 是放在 HashMap$Node中的 HashMap$Node node = newNode(hash,key,value,null)  ，而Node 实现了entry接口，用一个 Set 指向了Node 中的 Key，Collection的实现类 指向 Node中的 Value</p>
<h4 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h4><ul>
<li>put</li>
<li>remove</li>
<li>get</li>
<li>size</li>
<li>isEmpty</li>
<li>clear</li>
<li>containsKey</li>
</ul>
<h4 id="Map接口遍历方法"><a href="#Map接口遍历方法" class="headerlink" title="Map接口遍历方法"></a>Map接口遍历方法</h4><p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以直接把所有的value取出 然后遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection values = map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口的实现类-—-HashMap"><a href="#Map接口的实现类-—-HashMap" class="headerlink" title="Map接口的实现类 — HashMap"></a>Map接口的实现类 — HashMap</h3><ol>
<li>Map接口的常用实现类:HashMap、Hashtable和 Properties.</li>
<li>HashMap是 Map 接口使用频率最高的实现类。</li>
<li>HashMap 是以 key-val 对的方式来存储数据(HashMap$Node类型) </li>
<li>key不能重复,但是值可以重复,允许使用 null 键和 null 值。</li>
<li>如果添加相同的key，则会覆盖原来的key-val ,等同于修改.(key不会替换，val会替换)</li>
<li>与HashSet一样，不保证映射的顺序，因为底层是以hash表子储的.(jdk8的hashMap底层数组+链表 + 红黑树）</li>
<li>HashMap没有实现同步，因此是线程不安全的,方法没有做同步互斥的操作,没有 synchronized</li>
</ol>
<h4 id="HashMap-底层机制及源码剖析"><a href="#HashMap-底层机制及源码剖析" class="headerlink" title="HashMap 底层机制及源码剖析"></a>HashMap 底层机制及源码剖析</h4><ol>
<li>HashMap底层维护了Node类型的数组table，默认为null</li>
<li>当创建对象时，将加载因子（loadfactor）初始化为0.75</li>
<li>当添加 key - value 时，通过key的哈希值得到在table的索引，然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容</li>
<li>第一次添加，则需要扩容table的容量为16，临界值（threshold）为12</li>
<li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍即24，以此类推。</li>
<li>在Java8中，如果一条链表的元素个数超过了 TREEIEF_THRESHOLD(默认是8)，并且table的大小 &gt;= MIN_TREEIEF_CAPACITY(默认64)，就会进行树化（红黑树）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;java&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">    map.put(<span class="string">&quot;php&quot;</span>, <span class="number">10</span>);<span class="comment">//ok</span></span><br><span class="line">    map.put(<span class="string">&quot;java&quot;</span>, <span class="number">20</span>);<span class="comment">//替换value</span></span><br><span class="line">    System.out.println(<span class="string">&quot;map=&quot;</span> + map);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 执行构造器 new HashMap()</span></span><br><span class="line"><span class="comment">        初始化加载因子 loadfactor = 0.75</span></span><br><span class="line"><span class="comment">        HashMap$Node[] table = null</span></span><br><span class="line"><span class="comment">        2. 执行put 调用 hash 方法，计算 key 的 hash 值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">        public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span></span><br><span class="line"><span class="comment">        return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    3. 执行 putVal</span></span><br><span class="line"><span class="comment">        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                       boolean evict) &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span></span><br><span class="line"><span class="comment">        //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span></span><br><span class="line"><span class="comment">        if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">            n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">        韩顺平循序渐进学Java 零基础</span></span><br><span class="line"><span class="comment">            第679页</span></span><br><span class="line"><span class="comment">            //取出hash 值对应的table 的索引位置的Node, 如果为null, 就直接把加入的k-v</span></span><br><span class="line"><span class="comment">            //, 创建成一个 Node ,加入该位置即可</span></span><br><span class="line"><span class="comment">            if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">            Node&lt;K,V&gt; e; K k;//辅助变量</span></span><br><span class="line"><span class="comment">            // 如果table 的索引位置的key 的hash 相同和新的key 的hash 值相同，</span></span><br><span class="line"><span class="comment">            // 并 满足(table 现有的结点的key 和准备添加的key 是同一个对象 || equals 返回真)</span></span><br><span class="line"><span class="comment">            // 就认为不能加入新的k-v</span></span><br><span class="line"><span class="comment">            if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                e = p;</span></span><br><span class="line"><span class="comment">            else if (p instanceof TreeNode)//如果当前的table 的已有的Node 是红黑树，就按照红黑树的方式处</span></span><br><span class="line"><span class="comment">                理</span></span><br><span class="line"><span class="comment">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                //如果找到的结点，后面是链表，就循环比较</span></span><br><span class="line"><span class="comment">                for (int binCount = 0; ; ++binCount) &#123;//死循环</span></span><br><span class="line"><span class="comment">                    if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span></span><br><span class="line"><span class="comment">                        p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                        //加入后，判断当前链表的个数，是否已经到8 个，到8 个，后</span></span><br><span class="line"><span class="comment">                        //就调用 treeifyBin 方法进行红黑树的转换</span></span><br><span class="line"><span class="comment">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                            treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                        if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span></span><br><span class="line"><span class="comment">                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                            break;</span></span><br><span class="line"><span class="comment">                    p = e;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                    e.value = value; //替换，key 对应value</span></span><br><span class="line"><span class="comment">                afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                return oldValue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ++modCount;//每增加一个Node ,就size++</span></span><br><span class="line"><span class="comment">        if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span></span><br><span class="line"><span class="comment">            resize();</span></span><br><span class="line"><span class="comment">        afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    5. 关于树化(转成红黑树)</span></span><br><span class="line"><span class="comment">        //如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span></span><br><span class="line"><span class="comment">        //否则才会真正的树化 -&gt; 剪枝</span></span><br><span class="line"><span class="comment">        final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span></span><br><span class="line"><span class="comment">        int n, index; Node&lt;K,V&gt; e;</span></span><br><span class="line"><span class="comment">            if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line"><span class="comment">                resize();</span></span><br><span class="line"><span class="comment">    &#125;  */</span></span><br></pre></td></tr></table></figure>



<h4 id="HashMap小结"><a href="#HashMap小结" class="headerlink" title="HashMap小结"></a>HashMap小结</h4><p>要正确使用<code>HashMap</code>，作为<code>key</code>的类必须正确覆写<code>equals()</code>和<code>hashCode()</code>方法；</p>
<p>一个类如果覆写了<code>equals()</code>，就必须覆写<code>hashCode()</code>，并且覆写规则是：</p>
<ul>
<li>如果<code>equals()</code>返回<code>true</code>，则<code>hashCode()</code>返回值必须相等；</li>
<li>如果<code>equals()</code>返回<code>false</code>，则<code>hashCode()</code>返回值尽量不要相等。</li>
</ul>
<p>实现<code>hashCode()</code>方法可以通过<code>Objects.hashCode()</code>辅助方法实现。</p>
<h3 id="Map-接口实现类-—-HashTable"><a href="#Map-接口实现类-—-HashTable" class="headerlink" title="Map 接口实现类 — HashTable"></a>Map 接口实现类 — HashTable</h3><h4 id="HashTable基本介绍"><a href="#HashTable基本介绍" class="headerlink" title="HashTable基本介绍"></a>HashTable基本介绍</h4><ul>
<li>存放的元素是键值对：即 K-V</li>
<li>hashTable的键和值都不能为null，否则会抛出 NullPointerException</li>
<li>hashTable 使用的方法基本上和 HashMap一样</li>
<li>hashTable 是线程安全的（synchronized），hashMap是线程不安全的</li>
</ul>
<h4 id="HashTable底层"><a href="#HashTable底层" class="headerlink" title="HashTable底层"></a>HashTable底层</h4><ol>
<li>底层有数组 HashTable$Entry[]  初始化大小为11</li>
<li>threshold 为 8  11*0.75 = 8</li>
<li>扩容机制  *2+1   </li>
</ol>
<h4 id="HashTable-和-HashMap-对比"><a href="#HashTable-和-HashMap-对比" class="headerlink" title="HashTable 和 HashMap 对比"></a>HashTable 和 HashMap 对比</h4><table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全（同步）</th>
<th>效率</th>
<th>允许null键 null值</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>HashTable</td>
<td>1.0</td>
<td>安全</td>
<td>较高</td>
<td>不可以</td>
</tr>
</tbody></table>
<h3 id="Map-接口实现类-—-HashTable子类-Properties"><a href="#Map-接口实现类-—-HashTable子类-Properties" class="headerlink" title="Map 接口实现类 — HashTable子类    Properties"></a>Map 接口实现类 — HashTable子类    Properties</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>Properties类继承自HashTable类并实现了Map接口，也是使用一种键值对的形式来保存数据</li>
<li>他的特点和 HashTable类似</li>
<li>Properties 还可以用于从 xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</li>
</ol>
<h3 id="Map-接口实现类-—-TreeMap"><a href="#Map-接口实现类-—-TreeMap" class="headerlink" title="Map 接口实现类 — TreeMap"></a>Map 接口实现类 — TreeMap</h3><p>有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;orange&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apple, orange, pear</span></span><br></pre></td></tr></table></figure>

<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>在Java的标准库中，队列接口<code>Queue</code>定义了以下几个方法：（失败时前面抛出异常，后面返回false或null）</p>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除</li>
</ul>
<h4 id="使用PriorityQueue"><a href="#使用PriorityQueue" class="headerlink" title="使用PriorityQueue"></a>使用PriorityQueue</h4><p>放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Deque-双端队列"><a href="#使用Deque-双端队列" class="headerlink" title="使用Deque 双端队列"></a>使用Deque 双端队列</h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/hUZJ1I"><img src="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/hUZJ1I.png" alt="hUZJ1I.png"></a></p>
<h4 id="使用Stack"><a href="#使用Stack" class="headerlink" title="使用Stack"></a>使用Stack</h4><p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li>
</ul>
<h3 id="Java工具类Collections"><a href="#Java工具类Collections" class="headerlink" title="Java工具类Collections"></a>Java工具类Collections</h3><h4 id="Collections-工具类介绍"><a href="#Collections-工具类介绍" class="headerlink" title="Collections 工具类介绍"></a>Collections 工具类介绍</h4><ol>
<li>Collections 是一个操作Set、List 和 Map等集合的工具类</li>
<li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li>
</ol>
<h4 id="排序操作（均为static方法）"><a href="#排序操作（均为static方法）" class="headerlink" title="排序操作（均为static方法）"></a>排序操作（均为static方法）</h4><ul>
<li><p>反转    reverse</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">		Collections.reverse(numbers);</span><br></pre></td></tr></table></figure>
</li>
<li><p>混淆    shuffle</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.shuffle(numbers);</span><br></pre></td></tr></table></figure>

<ul>
<li>排序    sort</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(numbers);</span><br><span class="line">sort(List, COmparator)</span><br></pre></td></tr></table></figure>

<ul>
<li>交换    swap</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换0和5下标的数据</span></span><br><span class="line">Collections.swap(numbers,<span class="number">0</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>滚动    rotate</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把集合向右滚动2个单位</span></span><br><span class="line">Collections.rotate(numbers,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9B%86%E5%90%88/" rel="tag"># 集合</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/26/Mysql%E5%91%BD%E4%BB%A4%E8%A1%8C/" rel="prev" title="Mysql命令行操作">
                  <i class="fa fa-chevron-left"></i> Mysql命令行操作
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/27/%E5%8F%8D%E5%B0%84/" rel="next" title="反射">
                  反射 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youpeng</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
